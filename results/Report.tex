\documentclass{article}

\usepackage{algorithm}
\usepackage[noend]{algorithmic}

\usepackage{multirow}
\usepackage{datatool}
\usepackage{graphicx}



% TODO Add title
% VU Heuristic Optimization
%  SASTP, Exercise 1
%  Ioan Dragan, 
%  Stefan Hepp, 0026640

\title{SASTP \\
{VU Heuristic Optimization Techniques} }
\author{Stefan Hepp, 0026640 \\
Ioan Dragan, 0856561 }

\begin{document}
\maketitle
\section{General description of the framework and algorithms}

The solutions are represented as a list of spots to visit. The methods used to visit each spot are also stored in that list, but not the
resting time at the spots. Instead, we keep track of the total amount of stamina needed for the tour and calculate the resting time required 
at each node after the final solution has been selected. 
Since the stamina gained by resting is independent of the spot where the rest is added, this can be done in the following way: 
The total amount of required rest time is 
\[
\textit{total rest time} = \max\left(\frac{\textit{total required stamina} - \textit{initial stamina}}{\textit{habitus}},0\right)
\]
Beginning from the first spot in the tour, the amount of resting time for a spot is calculated as
\[
\textit{rest time} = \min\left(\textit{remaining rest time}, \frac{\textit{max stamina} - \textit{current stamina}}{\textit{habitus}}\right)
\]

By keeping track of the total time required to complete the tour (excluding rest times), as well as the total satisfaction gained after the tour and
the stamina reached at the end of the tour (excluding stamina gained by rests), new solutions can be calculated incrementally. 
To check if a neighborhood step leads to a valid solution, the total tour time is calculated as the tour time excluding rest plus
the total required rest time. The result is compared with the maximum time allowed for the tour.
\medskip

Two greedy heuristics have been implemented. They construct an initial solution by inserting spots with methods into the tour. The selection of the spots 
is done by keeping track of the highest ratio of gained satisfaction per time required for the visit.
The nearest neighbor greedy heuristic adds one of the $k$ nearest spots of the last spot at the end of the tour per step. The insert
heuristic selects one of the $k$ nearest spots of all spots in the tour and inserts it into the tour so that the travel time increase is minimized.
\medskip

For the local search and the VND, several neighborhoods have been implemented. 

The first neighborhood, $SpotOneOpt$, exchanges a single spot from the tour with an unused spot. The idea behind this neighborhood is to
be able to bring in outliers with with a high satisfaction value into the tour.
The \emph{best} step function searches for the best unused node to exchange with for all nodes in the tour.
This is done by keeping track of the node which promises the best improvement. %, and after checking all of them, swap the nodes and return the solution. 
The \emph{next} step function iterates over all the nodes in the tour and stops if replacing the node with an unused one leads to a valid
tour and improves the total satisfaction. 
For the \emph{random} step function a random spot in the tour and another spot from the unused spots are selected. 
The method is selected by starting at a random method of the spot and searching for the first feasible method that can be inserted into the
tour. If no method can be found, another random spot is choosen.
%As for method of the newly picked spot, it is also chosen randomly. 
%If the method makes the tour infeasible, then we try to iterate over all the methods of that specific spot and pick the first one which makes the tour valid.

The $EdgeTwoOpt$ neighborhood performs a 2-exchange on the edges of the tour. It removes crossovers and thus minimizes the travel distance
by crossing over two non-adjacent edges. 
% We could comment out that part, should be obvious.. 
The \emph{best} step function searches all pairs of edges for the best improvement. The \emph{next} step function looks at pairs of edges
with increasing distance between the edges for the first tour length improvement. The \emph{random} step function selects a pair of edges at
random. To simplify the implementation the random search does not continue if an infeasible edge exchange has been found.

The $MethodTwoOpt$ neighborhood changes the methods of two spots in the tour to improve the satisfaction. It picks two spots in the tour and
then searches all valid combinations of methods of the spots exhaustively for an improvement.
% No text on different step functions, should be clear.


% TODO NearestTourExchange, TwoNodeExchange



\medskip

The \emph{local search} is configured with one neighborhood. In every iteration it selects a new neighbor from the neighborhood, depending on the
step function. If the new neighbor results in a higher satisfaction, the search continues with that neighbor as the new solution. Otherwise
the search stops for the deterministic \emph{next} and \emph{best} step functions, or continues with the old solution for the \emph{random}
step function. In the latter case, the search terminates if either no improvement has been found for a fixed number of iterations or if a
timeout has been reached.

\emph{VND} is configured with a list of neighborhoods. In every iteration it selects a new neighbor from the neighborhood, depending on the
step function. When the neighborhood finds an improvement, the search falls back to the first neighborhood. Otherwise VND searches for improvements in the following neighborhoods.
The order in which the neighborhoods are searched has an impact on the results and the running times.

For the \emph{GRASP} procedure, a random greedy method was implemented. This provides the initial tour to optimize. Afterwards either local
search or VND is run to try to improve the solution. If the satisfaction of the newly found solution is greater than the one of the last
iteration of \emph{GRASP}, then this instance is kept. These steps are repeated until either there is no change in the satisfaction of the
solution for more than a fixed number of iterations or a timeout has been reached.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Here we load the files containing the results  %%%%%%%

\DTLloaddb[]{greedyNN}{greedy/AT_GREEDY_NN/greedy_AT_GREEDY_NN.csv}
\DTLloaddb[]{greedyIN}{greedy/AT_GREEDY_IN/greedy_AT_GREEDY_IN.csv}
\DTLloaddb[]{localOne}{localSearch/OneOptRepo.csv }
\DTLloaddb[]{localEdge}{localSearch/EdgeOptReport.csv}
\DTLloaddb[]{localMethod}{localSearch/MethodOptReport.csv}
\DTLloaddb[]{vndDeterministic}{VND/VNDResD.csv}
\DTLloaddb[]{vndThree}{VND/threeN/report.csv}
\DTLloaddb[]{graspOne}{grasp/oneOpt/oneOpt.csv}
\DTLloaddb[]{graspEdge}{grasp/edgeOpt/edgeOpt.csv}
\DTLloaddb[]{graspMethod}{grasp/methodOpt/methodOpt.csv}
\DTLloaddb[]{graspVND}{grasp/vndS.csv}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Greedy %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Results and discussion}

We have tested our approach with different configurations for the algorithms. 

The \emph{greedy algorithm} has been tested with both the strategies presented above. 
%In tables \ref{tab:greedyNN} and \ref{tab:GreedyIN} one can observe the results obtained using this algorithm for each of the problems. 
We also varied the value of $k$ for selecting the k-nearest spots (Table~\ref{tab:greedyNN} and Table~\ref{tab:GreedyIN}).
\medskip

\emph{Local search} was tested using all three neighborhoods, table \ref{tab:localOne} presents in more details the results obtained using spot exchange neighborhood. In table \ref{tab:localEdge} the same algorithm was run with the edge exchange neighborhood. As for the method exchange neighborhood, table \ref{tab:localMethod} presents the results. The best results using this search strategy were obtained with the spot exchange neighborhood. But the difference in stamina compared with the other neighborhoods is not that big. 
\medskip

\emph{VND} was also tested in different configurations (tables \ref{tab:vndDeterministic} and \ref{tab:vndThree}). As mentioned above the order in which the neighborhoods are searched makes a difference in the runtime of the algorithm. Also which neighborhoods are searched gives some difference in the total satisfaction. If we run vnd with all three methods active, we tend to get the same results, but the time spent in finding the result is bigger.  
\medskip

For \emph{grasp} we have tested with both local search and VND as main search engine. The results differ a lot, as printed out in tables \ref{tab:graspLSOne},  \ref{tab:graspLSEdge}, \ref{tab:graspLSMethod} and \ref{tab:graspVNDTwo}. Since grasp is a randomized search heuristic we've done multiple tests using the same configuration, computed the standard deviation and the averege satisfaction for each of the problems. Using this approach the best results where observed while testing the configuration which uses VND as search procedure. Among the local search procedures the best performing, in terms of total satisfaction is the one spot exchange method. The two approaches of VND give similar results, but the one using only the edge exchange and method exchange tends to terminate faster. 
\medskip

Among all the tested configurations,one of the best approaches is VND, which gives the best ratio of satisfaction per time spent in finding the solution. This approach gives also the highest satisfaction we can get for the sastp1000 problem.

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the greedy algorithm, nearest neighbor strategy}
  \setlength{\tabcolsep}{1.5mm}
  \centering
  \begin{tabular}{lrrrrl}
    \bfseries Problem &
    \bfseries Stamina &
    \bfseries Time &
    \bfseries Stam k=10& 
   	\bfseries Time 
    \DTLforeach{greedyNN}{\prob=problem,\stam=stamina,\time=time,\stamin=stamina1,\tim=time1}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \stam &\time & \stamin & \tim%
    }
    \\\hline
  \end{tabular}
\label{tab:greedyNN}
\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the greedy algorithm, insertion neighbor strategy}
  \label{tab:GreedyIN}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrl}
    \bfseries Problem &
    \bfseries Stamina &
    \bfseries Time &
    \bfseries Stam k=10& 
   	\bfseries Time 
    \DTLforeach{greedyIN}{\prob=problem,\stam=stamina,\time=time,\stamin=stamina1,\tim=time1}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \stam &\time & \stamin & \tim%
    }
    \\\hline
  \end{tabular}

\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%% Local Search %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the local search algorithm, using SpotOneOpt}
  \label{tab:localOne}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries St,Next &
    \bfseries Time &
    \bfseries St,Best &
    \bfseries Time &
    \bfseries Rand,k5 & 
    \bfseries dev &
    \bfseries Rand,k10& 
   	\bfseries dev
    \DTLforeach{localOne}{\prob=problem,\next=next,\ti=t1,\best=best,\tii=t2,\ki=k5,\devi=dev5,\kii=k10,\devii=dev10}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\ti & \best & \tii & \ki & \devi & \kii &\devii%
    }
    \\\hline
  \end{tabular}

\end{table}


\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the local search algorithm, using Edge Two Opt}
  \label{tab:localEdge}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries St,Next &
    \bfseries Time &
    \bfseries St,Best &
    \bfseries Time &
    \bfseries Rand,k5 & 
    \bfseries dev &
    \bfseries Rand,k10& 
   	\bfseries dev
    \DTLforeach{localEdge}{\prob=problem,\next=next,\ti=t1,\best=best,\tii=t2,\ki=k5,\devi=dev5,\kii=k10,\devii=dev10}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\ti & \best & \tii & \ki & \devi & \kii &\devii%
    }
    \\\hline
  \end{tabular}

\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the local search algorithm, using Method Two Opt}
  \label{tab:localMethod}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrr}
    \bfseries Problem &
    \bfseries St,Next &
    \bfseries Time &
    \bfseries Rand,k5 & 
    \bfseries dev &
    \bfseries Rand,k10& 
   	\bfseries dev
    \DTLforeach{localMethod}{\prob=problem,\next=next,\ti=t1,\ki=k5,\devi=dev5,\kii=k10,\devii=dev10}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\ti & \ki & \devi & \kii &\devii%
    }
    \\\hline
  \end{tabular}

\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% VND %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the VND, using step function Next and Best, with only edge and method neighborhoods active }
  \label{tab:vndDeterministic}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries Next &
    \bfseries K=5 &
    \bfseries K=15 &
    \bfseries AvgTime &
    \bfseries Best & 
    \bfseries K=5 &
    \bfseries K=15& 
   	\bfseries AvgTime
    \DTLforeach{vndDeterministic}{\prob=problem,\next=next,\nkv=nk5,\nkxv=nk15,\avgti=avgt1,\best=best,\kv=k5,\kxv=k15,\avgtii=avgt2}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\nkv & \nkxv & \avgti & \best & \kv & \kxv &\avgtii%
    }
    \\\hline
  \end{tabular}

\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the VND, using step function Next and Best with all three neighborhoods active }
  \label{tab:vndThree}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrr}
    \bfseries Problem &
    \bfseries Next &
    \bfseries NTime &
    \bfseries Best & 
    \bfseries Btime &
    \bfseries Random &
    \bfseries Rtime 
    \DTLforeach{vndThree}{\prob=problem,\rand=rand,\rtime=rtime,\next=next,\ntime=ntime,\best=best,\btime=btime}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\ntime & \best & \btime & \rand & \rtime%
    }
    \\\hline
  \end{tabular}

\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% GRASP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Grasp using the local search, oneOpt, using step function Next and Best and Random }
  \label{tab:graspLSOne}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries Best &
    \bfseries Dev &
    \bfseries Next &
    \bfseries Dev &
    \bfseries Random & 
    \bfseries Dev
    \DTLforeach{graspOne}{\prob=problem,\best=best,\devb=devb,\next=next,\devn=devn,\rand=rand,\devr=devr}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob &\best & \devb & \next & \devn & \rand & \devr%
    }
    \\\hline
  \end{tabular}

\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Grasp using the local search, edgeOption, using step function Next and Random }
  \label{tab:graspLSEdge}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries Best &
    \bfseries Dev &
    \bfseries Next &
    \bfseries Dev &
    \bfseries Random & 
    \bfseries Dev
    \DTLforeach{graspEdge}{\prob=problem,\best=best,\devb=devb,\next=next,\devn=devn,\rand=rand,\devr=devr}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob &\best & \devb & \next & \devn & \rand & \devr%
    }
    \\\hline
  \end{tabular}

\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Grasp using the local search , methodOpt and step function Next and Best }
  \label{tab:graspLSMethod}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries Next &
    \bfseries Dev &
    \bfseries Random &
    \bfseries Dev  
    \DTLforeach{graspMethod}{\prob=problem,\next=next,\dev=dev,\random=random,\devr=devr}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\dev & \random & \devr %
    }
    \\\hline
  \end{tabular}

\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Grasp using the VND with step function Next and Best, only EdgeOpt and MethodOpt active as neighborhoods }
  \label{tab:graspVNDTwo}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries Next &
    \bfseries Dev &
    \bfseries AvgTime &
    \bfseries Best & 
    \bfseries Dev &
    \bfseries AvgTime
    \DTLforeach{graspVND}{\prob=problem,\next=next,\dev=dev,\time=time,\best=best,\bdev=bdev,\btime=btime}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\dev & \time & \best & \bdev & \btime%
    }
    \\\hline
  \end{tabular}

\end{table}

%TODO add the latest test results for grasp with vnd and all three neighborhoods active -- still running... 


% TODO compare various configurations
% - single neighborhoods not good enough if tour length does not change
% - Order of neighborhoods in VND important for runtime, maybe for quality of results (TODO check results..)
% - describe best configuration



\end{document}
