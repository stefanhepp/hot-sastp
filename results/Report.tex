\documentclass{article}

\usepackage{algorithm}
\usepackage[noend]{algorithmic}

\usepackage{multirow}
\usepackage{datatool}
\usepackage{graphicx}

\begin{document}
\section{General description of the framework and algorithms}

The solutions are represented as a list of spots to visit. The methods used to visit each spot is also stored in that list, but not the
resting time at the spots. Instead, we keep track of the total amount of stamina needed for the tour and calculate the resting time required 
at each node after the final solution has been selected. 
Since the stamina gained by resting is independent of the spot where the rest is added, this can be done in the following way: 
The total amount of required rest time is 
\[
\textit{total rest time} = \max\left(\frac{\textit{total required stamina} - \textit{initial stamina}}{\textit{habitus}},0\right)
\]
Beginning from the first spot in the tour, the amount of resting time for a spot is calculated as
\[
\textit{rest time} = \min\left(\textit{remaining rest time}, \frac{\textit{max stamina} - \textit{current stamina}}{\textit{habitus}}\right)
\]

By keeping track of the total time required to complete the tour (excluding rest times), the total satisfaction gained after the tour and
the stamina reached at the end of the tour (excluding stamina gained by rests), new solutions can be calculated incrementally. 
To check if a neighborhood step leads to a valid solution, the total tour time is calculated as the tour time excluding rest plus
the total required rest time and compared with the maximum time allowed for the tour.
\medskip

Two greedy heuristics have been implemented, they construct an initial solution by inserting spots with methods into the tour. The selection of the spots is done by keeping track of the highest ratio of gained satisfaction per used time. The nearest neighbor greedy heuristic adds one of the $k$ nearest spots of the last spot in the tour per step. The insert
heuristic selects one of the $k$ nearest spots of all spots in the tour and inserts it into the tour so that the travel time is minimized.
\medskip

For the local search and the VND, several neighborhoods have been implemented. 

% TODO describe neighborhoods

The first neighborhood, $SpotOneOpt$ exchanges a single spot from the tour with an unused spot. The \emph{best} step function, for each node in the tour finds the best unused node to exchange with. This is done by keeping track of the node which promises the best improvement, and after checking all of them, swap the nodes and return the solution. The \emph{next} step function, iterate over all the nodes in the tour, and checks if by replacing the node with an unused one any improvement has been made to the tour. If that is the case, then the replacement of the nodes is done and the function returns the result. For the \emph{random} step function, one just picks a spot in the tour, and another spot from the k-nearest unused spots, and tries to exchange those two. As for method of the newly picked spot, it is also chosen randomly. If the method makes the tour infeasible, then we try to iterate over all the methods of that specific spot and pick the first one which makes the tour valid.
\medskip

The \emph{local search} is configured with one neighborhood. In every iteration it selects a new neighbor from the neighborhood, depending on the
step function. If the new neighbor results in a higher satisfaction, the search continues with that neighbor as the new solution. Otherwise
the search stops for the deterministic \emph{next} and \emph{best} step functions, or continues with the old solution for the \emph{random}
step function. In the latter case, the search terminates if either no improvement has been found for a fixed number of iterations or if a
timeout has been reached.
\medskip
% TODO very short description of VND, Grasp: neighborhoods used and their order, termination criteria.

\emph{VND} is configured with a list of neighborhoods.  In every iteration it selects a new neighborhood. Then it selects a new neighbor from the neighborhood, depending on the step function, and as long as there is an improvement in that neighborhood, it performs the steps. When that neighborhood does not provide an improvement the search checks for improvements in the other neighborhoods from the list. The order in which the neighborhoods are searched gives different results.  

For the \emph{grasp} procedure, a random greedy method is implemented. This provides the initial tour to optimize. Then either local search or VND is run and try to improve the solution. If the satisfaction of the newly found solution is bigger than the one we started with, then we keep this instance. These steps are repeated until either there is no change in the satisfaction of the solution for more than a fixed number of iterations or timeout has been reached.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Here we load the files containing the results  %%%%%%%

\DTLloaddb[]{greedyNN}{greedy/AT_GREEDY_NN/greedy_AT_GREEDY_NN.csv}
\DTLloaddb[]{greedyIN}{greedy/AT_GREEDY_IN/greedy_AT_GREEDY_IN.csv}
\DTLloaddb[]{localOne}{localSearch/OneOptRepo.csv }
\DTLloaddb[]{localEdge}{localSearch/EdgeOptReport.csv}
\DTLloaddb[]{localMethod}{localSearch/MethodOptReport.csv}
\DTLloaddb[]{vndDeterministic}{VND/VNDResD.csv}
\DTLloaddb[]{vndThree}{VND/threeN/report.csv}
\DTLloaddb[]{graspOne}{grasp/oneOpt/oneOpt.csv}
\DTLloaddb[]{graspEdge}{grasp/edgeOpt/edgeOpt.csv}
\DTLloaddb[]{graspMethod}{grasp/methodOpt/methodOpt.csv}
\DTLloaddb[]{graspVND}{grasp/vndS.csv}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Greedy %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Results and discussion}

% TODO very short description of configurations for each table.
We have tested our approach with different configurations for the algorithms. 

The greedy algorithm has been tested with both the strategies presented above. In tables \ref{tab:greedyNN} and \ref{tab:GreedyIN} one can observe the results obtained using this algorithm for each of the problems. We also tried different values for selecting the k-nearest spots. 
\medskip

\emph{Local search} was tested using all three neighborhoods, table \ref{tab:localOne} presents in more details the results obtained using spot exchange neighborhood. In table \ref{tab:localEdge} the same algorithm was run with the edge exchange neighborhood. As for the method exchange neighborhood, table \ref{tab:localMethod} presents the results. The best results using this search strategy were obtained with the spot exchange neighborhood. But the difference in stamina compared with the other neighborhoods is not that big. 
\medskip

\emph{VND} was also tested in different configurations (tables \ref{tab:vndDeterministic} and \ref{tab:vndThree}). As mentioned above the order in which the neighborhoods are searched makes a difference in the runtime of the algorithm. Also which neighborhoods are searched gives some difference in the total satisfaction. If we run vnd with all three methods active, we tend to get the same results, but the time spent in finding the result is bigger.  
\medskip

For \emph{grasp} we have tested with both local search and VND as main search engine. The results differ a lot, as printed out in tables \ref{tab:graspLSOne},  \ref{tab:graspLSEdge}, \ref{tab:graspLSMethod} and \ref{tab:graspVNDTwo}. Since grasp is a randomized search heuristic we've done multiple tests using the same configuration, computed the standard deviation and the averege satisfaction for each of the problems. Using this approach the best results where observed while testing the configuration which uses VND as search procedure. Among the local search procedures the best performing, in terms of total satisfaction is the one spot exchange method. The two approaches of VND give similar results, but the one using only the edge exchange and method exchange tends to terminate faster. 
\medskip

Among all the tested configurations,one of the best approaches is VND, which gives the best ratio of satisfaction per time spent in finding the solution. This approach gives also the highest satisfaction we can get for the sastp1000 problem.

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the greedy algorithm, nearest neighbor strategy}
  \setlength{\tabcolsep}{1.5mm}
  \centering
  \begin{tabular}{lrrrrl}
    \bfseries Problem &
    \bfseries Stamina &
    \bfseries Time &
    \bfseries Stam k=10& 
   	\bfseries Time 
    \DTLforeach{greedyNN}{\prob=problem,\stam=stamina,\time=time,\stamin=stamina1,\tim=time1}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \stam &\time & \stamin & \tim%
    }
    \\\hline
  \end{tabular}
\label{tab:greedyNN}
\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the greedy algorithm, insertion neighbor strategy}
  \label{tab:GreedyIN}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrl}
    \bfseries Problem &
    \bfseries Stamina &
    \bfseries Time &
    \bfseries Stam k=10& 
   	\bfseries Time 
    \DTLforeach{greedyIN}{\prob=problem,\stam=stamina,\time=time,\stamin=stamina1,\tim=time1}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \stam &\time & \stamin & \tim%
    }
    \\\hline
  \end{tabular}

\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%% Local Search %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the local search algorithm, using SpotOneOpt}
  \label{tab:localOne}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries St,Next &
    \bfseries Time &
    \bfseries St,Best &
    \bfseries Time &
    \bfseries Rand,k5 & 
    \bfseries dev &
    \bfseries Rand,k10& 
   	\bfseries dev
    \DTLforeach{localOne}{\prob=problem,\next=next,\ti=t1,\best=best,\tii=t2,\ki=k5,\devi=dev5,\kii=k10,\devii=dev10}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\ti & \best & \tii & \ki & \devi & \kii &\devii%
    }
    \\\hline
  \end{tabular}

\end{table}


\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the local search algorithm, using Edge Two Opt}
  \label{tab:localEdge}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries St,Next &
    \bfseries Time &
    \bfseries St,Best &
    \bfseries Time &
    \bfseries Rand,k5 & 
    \bfseries dev &
    \bfseries Rand,k10& 
   	\bfseries dev
    \DTLforeach{localEdge}{\prob=problem,\next=next,\ti=t1,\best=best,\tii=t2,\ki=k5,\devi=dev5,\kii=k10,\devii=dev10}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\ti & \best & \tii & \ki & \devi & \kii &\devii%
    }
    \\\hline
  \end{tabular}

\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the local search algorithm, using Method Two Opt}
  \label{tab:localMethod}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrr}
    \bfseries Problem &
    \bfseries St,Next &
    \bfseries Time &
    \bfseries Rand,k5 & 
    \bfseries dev &
    \bfseries Rand,k10& 
   	\bfseries dev
    \DTLforeach{localMethod}{\prob=problem,\next=next,\ti=t1,\ki=k5,\devi=dev5,\kii=k10,\devii=dev10}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\ti & \ki & \devi & \kii &\devii%
    }
    \\\hline
  \end{tabular}

\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% VND %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the VND, using step function Next and Best, with only edge and method neighborhoods active }
  \label{tab:vndDeterministic}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries Next &
    \bfseries K=5 &
    \bfseries K=15 &
    \bfseries AvgTime &
    \bfseries Best & 
    \bfseries K=5 &
    \bfseries K=15& 
   	\bfseries AvgTime
    \DTLforeach{vndDeterministic}{\prob=problem,\next=next,\nkv=nk5,\nkxv=nk15,\avgti=avgt1,\best=best,\kv=k5,\kxv=k15,\avgtii=avgt2}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\nkv & \nkxv & \avgti & \best & \kv & \kxv &\avgtii%
    }
    \\\hline
  \end{tabular}

\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Computed values using the VND, using step function Next and Best with all three neighborhoods active }
  \label{tab:vndThree}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrr}
    \bfseries Problem &
    \bfseries Next &
    \bfseries NTime &
    \bfseries Best & 
    \bfseries Btime &
    \bfseries Random &
    \bfseries Rtime 
    \DTLforeach{vndThree}{\prob=problem,\rand=rand,\rtime=rtime,\next=next,\ntime=ntime,\best=best,\btime=btime}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\ntime & \best & \btime & \rand & \rtime%
    }
    \\\hline
  \end{tabular}

\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%% GRASP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Grasp using the local search, oneOpt, using step function Next and Best and Random }
  \label{tab:graspLSOne}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries Best &
    \bfseries Dev &
    \bfseries Next &
    \bfseries Dev &
    \bfseries Random & 
    \bfseries Dev
    \DTLforeach{graspOne}{\prob=problem,\best=best,\devb=devb,\next=next,\devn=devn,\rand=rand,\devr=devr}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob &\best & \devb & \next & \devn & \rand & \devr%
    }
    \\\hline
  \end{tabular}

\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Grasp using the local search, edgeOption, using step function Next and Random }
  \label{tab:graspLSEdge}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries Best &
    \bfseries Dev &
    \bfseries Next &
    \bfseries Dev &
    \bfseries Random & 
    \bfseries Dev
    \DTLforeach{graspEdge}{\prob=problem,\best=best,\devb=devb,\next=next,\devn=devn,\rand=rand,\devr=devr}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob &\best & \devb & \next & \devn & \rand & \devr%
    }
    \\\hline
  \end{tabular}

\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Grasp using the local search , methodOpt and step function Next and Best }
  \label{tab:graspLSMethod}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries Next &
    \bfseries Dev &
    \bfseries Random &
    \bfseries Dev  
    \DTLforeach{graspMethod}{\prob=problem,\next=next,\dev=dev,\random=random,\devr=devr}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\dev & \random & \devr %
    }
    \\\hline
  \end{tabular}

\end{table}

\begin{table}[b!]
  \vspace{-6mm}%
  \caption{Grasp using the VND with step function Next and Best, only EdgeOpt and MethodOpt active as neighborhoods }
  \label{tab:graspVNDTwo}
  \setlength{\tabcolsep}{1.4mm}
  \centering
  \begin{tabular}{lrrrrrrrrrr}
    \bfseries Problem &
    \bfseries Next &
    \bfseries Dev &
    \bfseries AvgTime &
    \bfseries Best & 
    \bfseries Dev &
    \bfseries AvgTime
    \DTLforeach{graspVND}{\prob=problem,\next=next,\dev=dev,\time=time,\best=best,\bdev=bdev,\btime=btime}{%
      \DTLiffirstrow{\\\hline}{\\}%
      \prob & \next &\dev & \time & \best & \bdev & \btime%
    }
    \\\hline
  \end{tabular}

\end{table}

%TODO add the latest test results for grasp with vnd and all three neighborhoods active -- still running... 


% TODO compare various configurations
% - single neighborhoods not good enough if tour length does not change
% - Order of neighborhoods in VND important for runtime, maybe for quality of results (TODO check results..)
% - describe best configuration



\end{document}
